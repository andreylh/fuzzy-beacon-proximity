package br.ufsc.proximity;

import java.io.File;
import java.io.IOException;
import java.util.Locale;

import com.fuzzylite.Engine;
import com.fuzzylite.Op;
import com.fuzzylite.activation.General;
import com.fuzzylite.defuzzifier.Bisector;
import com.fuzzylite.defuzzifier.Centroid;
import com.fuzzylite.defuzzifier.Defuzzifier;
import com.fuzzylite.defuzzifier.LargestOfMaximum;
import com.fuzzylite.defuzzifier.MeanOfMaximum;
import com.fuzzylite.defuzzifier.SmallestOfMaximum;
import com.fuzzylite.defuzzifier.WeightedAverage;
import com.fuzzylite.defuzzifier.WeightedDefuzzifier.Type;
import com.fuzzylite.imex.RScriptExporter;
import com.fuzzylite.norm.SNorm;
import com.fuzzylite.norm.TNorm;
import com.fuzzylite.norm.s.Maximum;
import com.fuzzylite.norm.t.AlgebraicProduct;
import com.fuzzylite.norm.t.BoundedDifference;
import com.fuzzylite.norm.t.DrasticProduct;
import com.fuzzylite.norm.t.Minimum;
import com.fuzzylite.rule.Rule;
import com.fuzzylite.rule.RuleBlock;
import com.fuzzylite.term.Ramp;
import com.fuzzylite.term.Trapezoid;
import com.fuzzylite.term.Triangle;
import com.fuzzylite.variable.InputVariable;
import com.fuzzylite.variable.OutputVariable;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class ProximityMain {

	public static void main(String[] args) throws Exception {
		Locale.setDefault(new Locale("en", "US"));
		
		//Defaults: 0 0 min max min centroid false
		
		if (args.length < 6) {
			throw new Exception("args: signal distance tnorm aggregation implication defuzzifier");
		}
		
		double signal = Double.parseDouble(args[0]);
		double distance = Double.parseDouble(args[1]);
		TNorm tNorm = getTNorm(args[2]);
		SNorm aggregation = getAggregation(args[3]);
		TNorm implication = getImplication(args[4]);
		Defuzzifier defuzzifier = getDefuzzifier(args[5]);
		boolean plot = false;
		
		if (args.length > 6) {
			plot = Boolean.parseBoolean(args[6]);
		}
		
		FuzzyProximity fuzzy = new FuzzyProximity();		
		fuzzy.tNorm = tNorm;		
		fuzzy.implication = implication;
		fuzzy.aggregation = aggregation;		
		fuzzy.defuzzifier = defuzzifier;
		fuzzy.execute(signal, distance, plot);
	}
	
	private static TNorm getTNorm(String str) throws Exception {
		String aux = str.trim().toLowerCase();
		
		if (aux.equals("min")) return new Minimum(); //padrão
		if (aux.equals("prod")) return new AlgebraicProduct(); //produto algébrico
		if (aux.equals("bdiff")) return new BoundedDifference(); //diferença limitada
		if (aux.equals("drastic")) return new DrasticProduct(); //intersção drástica (hard)
		
		throw new Exception("invalid tNorm. Supported: min, prod, bdiff, drastic");
	}
	
	private static SNorm getAggregation(String str) throws Exception {
		String aux = str.trim().toLowerCase();
		
		if (aux.equals("max")) return new Maximum();
		if (aux.equals("min")) return new SMinimum();
		
		throw new Exception("invalid aggregation. Supported: max, min");
	}
	
	private static TNorm getImplication(String str) throws Exception {
		String aux = str.trim().toLowerCase();
		
		if (aux.equals("min")) return new Minimum();
		if (aux.equals("prod")) return new AlgebraicProduct();
		if (aux.equals("max")) return new TMaximum();
		
		throw new Exception("invalid implication. Supported: min, prod, max");
	}
	
	private static Defuzzifier getDefuzzifier(String str) throws Exception {
		String aux = str.trim().toLowerCase();
		
		if (aux.equals("centroid")) return new Centroid(100);
		if (aux.equals("meanmax")) return new MeanOfMaximum();
		if (aux.equals("smallestmax")) return new SmallestOfMaximum();
		if (aux.equals("largestmax")) return new LargestOfMaximum();
		if (aux.equals("bisector")) return new Bisector();
		if (aux.equals("wavgmax")) return new WeightedAverage(Type.Tsukamoto);
		
		throw new Exception("invalid defuzzifier. Supported: centroid, meanmax, smallestmax, largestmax, bisector, wavgmax");
	}
	
}

class FuzzyProximity {
	/*
	 t-normas
	   new Minimum() - intersção padrão (soft)
	   new AlgebraicProduct() - produto algébrico
	   new BoundedDifference() - diferença limitada
	   new DrasticProduct() - intersção drástica (hard)
	*/
	public TNorm tNorm = null;
	
	/*
	 agregação, implicação
	 max-min
	   new Maximum()
	   new Minimum()
    max-produto
      new Maximum()
	   new AlgebraicProduct()
    min-max
      new SMinimum()
      new Maximum()
    max-max
      new Maximum()
      new Maximum()
    min-min
      new SMinimum()
      new Minimum()
	*/
	public SNorm aggregation = null;
	public TNorm implication = null;	
	
	/*
	 Centro de Massa ou Centroide - CG
	   new Centroid(100)
     Média dos Máximos - MM
       new MeanOfMaximum()
     Média Ponderada dos Máximos – MPM
       new WeightedAverage(Type.Tsukamoto)
	 */
	public Defuzzifier defuzzifier = null;
	
	public void execute(double signalValue, double distanceValue, boolean plot) throws IOException {
		Engine engine = new Engine();
		engine.setName("Proximity");
		engine.setDescription("");
		
		InputVariable signal = new InputVariable();
		signal.setName("signal");
		signal.setDescription("");
		signal.setEnabled(true);
		signal.setRange(50.0, 100.0);
		signal.setLockValueInRange(true);
		signal.addTerm(new Trapezoid("strong", 50, 50, 65.0, 70.0));
		signal.addTerm(new Triangle("decent", 65.0, 70.0, 75.0));
		signal.addTerm(new Trapezoid("weak", 73.0, 75.0, 100.0, 100.0));
		engine.addInputVariable(signal);
		
		InputVariable distance = new InputVariable();
		distance.setName("distance");
		distance.setDescription("");
		distance.setEnabled(true);
		distance.setRange(0.0, 1200);
		distance.setLockValueInRange(true);
		distance.addTerm(new Trapezoid("low", 0, 0, 160, 200));
		distance.addTerm(new Trapezoid("medium", 160, 250, 400, 490));
		distance.addTerm(new Trapezoid("high", 470, 580, 1200, 1200));
		engine.addInputVariable(distance);
		
		OutputVariable proximity = new OutputVariable();
		proximity.setName("proximity");
		proximity.setDescription("");
		proximity.setEnabled(true);
		proximity.setRange(0.0, 1200.0);
		proximity.setLockValueInRange(false);
		proximity.setAggregation(aggregation);
		proximity.setDefuzzifier(defuzzifier);
		proximity.setDefaultValue(Double.NaN);
		proximity.setLockPreviousValue(false);
		proximity.addTerm(new Trapezoid("immediate", 0, 0, 100, 200));
		proximity.addTerm(new Trapezoid("near", 100, 400, 600, 800));
		proximity.addTerm(new Ramp("far", 600, 1200));
        engine.addOutputVariable(proximity);
        
        RuleBlock mamdani = new RuleBlock();
        mamdani.setName("mamdani");
        mamdani.setDescription("");
        mamdani.setEnabled(true);
        mamdani.setConjunction(tNorm);
        mamdani.setDisjunction(null);
        mamdani.setImplication(implication);
        mamdani.setActivation(new General());
        mamdani.addRule(Rule.parse("if signal is strong then proximity is immediate", engine));
    	mamdani.addRule(Rule.parse("if signal is decent and distance is low then proximity is immediate", engine));
    	mamdani.addRule(Rule.parse("if signal is decent and distance is medium then proximity is near", engine));
        mamdani.addRule(Rule.parse("if signal is decent and distance is high then proximity is near", engine));
        mamdani.addRule(Rule.parse("if signal is weak and distance is low then proximity is near", engine));
        mamdani.addRule(Rule.parse("if signal is weak and distance is medium then proximity is far", engine));
        mamdani.addRule(Rule.parse("if signal is weak and distance is high then proximity is far", engine));
        engine.addRuleBlock(mamdani);
        
        signal.setValue(signalValue);
        distance.setValue(distanceValue);
        engine.process();
        System.out.println(String.format("%s %s %s %s",
        		Op.str(proximity.getValue()),
        		proximity.fuzzyOutput().activationDegree(proximity.getTerm(0)),
        		proximity.fuzzyOutput().activationDegree(proximity.getTerm(1)),
        		proximity.fuzzyOutput().activationDegree(proximity.getTerm(2))));
        
        if (plot) {
        	RScriptExporter exporter = new RScriptExporter();
        	exporter.toFile(new File("plot.r"), engine);
        }
	}
}

class Lukasiewicz extends TNorm {

    @Override
    public double compute(double a, double b) {
        return Op.min(1, 1 - a + b);
    }

    @Override
    public Lukasiewicz clone() throws CloneNotSupportedException {
        return (Lukasiewicz) super.clone();
    }
}

class LimitedSum extends TNorm {
	
	@Override
    public double compute(double a, double b) {
        return Op.min(1, a + b);
    }

    @Override
    public LimitedSum clone() throws CloneNotSupportedException {
        return (LimitedSum) super.clone();
    }
}

class Goguen extends TNorm {
	
	@Override
    public double compute(double a, double b) {
        return Op.min(1, b / a);
    }

    @Override
    public Goguen clone() throws CloneNotSupportedException {
        return (Goguen) super.clone();
    }
}

class SMinimum extends SNorm {

	@Override
	public double compute(double a, double b) {
		return Op.min(a, b);
	}
	
}

class TMaximum extends TNorm {

	@Override
	public double compute(double a, double b) {
		return Op.max(a, b);
	}
	
}